package server

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// EnvSection represents a section in the .env file
type EnvSection struct {
	Name      string            // e.g., "Google Cloud Platform (GCP)"
	Variables map[string]string // key-value pairs for this section
}

// EnvManager manages the shared .env file with section-based updates
type EnvManager struct {
	filePath string
	sections map[string]*EnvSection // section name -> EnvSection
}

// NewEnvManager creates a new EnvManager for the project root .env file
func NewEnvManager() (*EnvManager, error) {
	envPath, err := getProjectRootEnvPath()
	if err != nil {
		return nil, err
	}

	em := &EnvManager{
		filePath: envPath,
		sections: make(map[string]*EnvSection),
	}

	// Load existing .env file if it exists
	if err := em.load(); err != nil && !os.IsNotExist(err) {
		return nil, fmt.Errorf("failed to load .env: %w", err)
	}

	return em, nil
}

// getProjectRootEnvPath finds the project root and returns .env path
func getProjectRootEnvPath() (string, error) {
	cwd, err := os.Getwd()
	if err != nil {
		return "", fmt.Errorf("could not get working directory: %w", err)
	}

	// Walk up directories to find project root (where go.mod exists)
	dir := cwd
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			// Found project root
			return filepath.Join(dir, ".env"), nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			// Reached filesystem root without finding go.mod
			return filepath.Join(cwd, ".env"), nil
		}
		dir = parent
	}
}

// load reads the .env file and parses it into sections
func (em *EnvManager) load() error {
	file, err := os.Open(em.filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	var currentSection *EnvSection
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Detect section headers: # === Section Name ===
		if strings.HasPrefix(line, "# ===") && strings.HasSuffix(line, "===") {
			sectionName := strings.TrimSpace(strings.Trim(strings.Trim(line, "#"), "="))
			currentSection = &EnvSection{
				Name:      sectionName,
				Variables: make(map[string]string),
			}
			em.sections[sectionName] = currentSection
			continue
		}

		// Skip comments and empty lines
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Parse key=value pairs
		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			continue
		}

		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		// Add to current section if we're in one
		if currentSection != nil {
			currentSection.Variables[key] = value
		}
	}

	return scanner.Err()
}

// GetSection returns variables for a specific section
func (em *EnvManager) GetSection(sectionName string) map[string]string {
	if section, ok := em.sections[sectionName]; ok {
		// Return a copy to prevent external modifications
		result := make(map[string]string)
		for k, v := range section.Variables {
			result[k] = v
		}
		return result
	}
	return make(map[string]string)
}

// UpdateSection updates or creates a section with new variables
// Only updates the specified section, leaves others untouched
func (em *EnvManager) UpdateSection(sectionName string, variables map[string]string) error {
	// Update in-memory section
	if section, ok := em.sections[sectionName]; ok {
		// Update existing section
		for k, v := range variables {
			section.Variables[k] = v
		}
	} else {
		// Create new section
		em.sections[sectionName] = &EnvSection{
			Name:      sectionName,
			Variables: variables,
		}
	}

	// Save to file
	return em.save()
}

// save writes all sections back to the .env file
func (em *EnvManager) save() error {
	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(em.filePath), 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	var content strings.Builder
	content.WriteString("# Wellknown Cloud Provider Configuration\n")
	content.WriteString("# Generated by: Wellknown Setup Wizard\n")
	content.WriteString("# Each section can be independently configured\n\n")

	// Define section order
	sectionOrder := []string{
		"Google Cloud Platform (GCP)",
		"Cloudflare",
		"Fly.io",
		"Pocketbase Admin",
	}

	// Write sections in order
	for _, sectionName := range sectionOrder {
		section, exists := em.sections[sectionName]
		if !exists {
			// Write placeholder for missing sections
			content.WriteString(fmt.Sprintf("# === %s ===\n", sectionName))
			content.WriteString(em.getPlaceholderForSection(sectionName))
			content.WriteString("\n")
			continue
		}

		// Write section header
		content.WriteString(fmt.Sprintf("# === %s ===\n", section.Name))

		// Write variables
		for key, value := range section.Variables {
			if value != "" {
				content.WriteString(fmt.Sprintf("%s=%s\n", key, value))
			} else {
				content.WriteString(fmt.Sprintf("# %s=\n", key))
			}
		}
		content.WriteString("\n")
	}

	// Write file with secure permissions
	if err := os.WriteFile(em.filePath, []byte(content.String()), 0600); err != nil {
		return fmt.Errorf("failed to write .env file: %w", err)
	}

	return nil
}

// getPlaceholderForSection returns placeholder variables for a section
func (em *EnvManager) getPlaceholderForSection(sectionName string) string {
	switch sectionName {
	case "Google Cloud Platform (GCP)":
		return `# GCP_PROJECT_ID=
# GOOGLE_CLIENT_ID=
# GOOGLE_CLIENT_SECRET=
# GOOGLE_REDIRECT_URL=http://localhost:8090/auth/google/callback
`
	case "Cloudflare":
		return `# CLOUDFLARE_API_TOKEN=
# CLOUDFLARE_ACCOUNT_ID=
# CLOUDFLARE_ZONE_ID=
`
	case "Fly.io":
		return `# FLY_API_TOKEN=
# FLY_ORG=
# FLY_APP_NAME=
`
	case "Pocketbase Admin":
		return `# PB_ADMIN_EMAIL=admin@example.com
# PB_ADMIN_PASSWORD=changeme123
`
	default:
		return ""
	}
}

// GetFilePath returns the path to the .env file
func (em *EnvManager) GetFilePath() string {
	return em.filePath
}
